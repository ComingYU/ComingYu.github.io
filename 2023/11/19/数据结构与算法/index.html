<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="各种算法可视化网站：https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html 线性结构查找算法 顺序查找基本思路：从第一个元素开始逐个与需要查找的元素进行比较，当找到相同的元素时返回该元素的下标，否则返回-1.复杂度分析：查找成功时，平均查找长度ASL&#x3D;（n+1）&#x2F;2;查找不成功时，需要n+1次比较，故时间复杂">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ComingYu">
<meta property="og:description" content="各种算法可视化网站：https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html 线性结构查找算法 顺序查找基本思路：从第一个元素开始逐个与需要查找的元素进行比较，当找到相同的元素时返回该元素的下标，否则返回-1.复杂度分析：查找成功时，平均查找长度ASL&#x3D;（n+1）&#x2F;2;查找不成功时，需要n+1次比较，故时间复杂">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210222174500547.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210222180209672.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/337b730e1f2b41aeac150763f10256e4.png">
<meta property="article:published_time" content="2023-11-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-06T16:14:38.521Z">
<meta property="article:author" content="Mingyu Kang">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210222174500547.png#pic_center">

<link rel="canonical" href="http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法 | ComingYu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ComingYu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mingyu Kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ComingYu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-19 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-19T00:00:00+08:00">2023-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-07 00:14:38" itemprop="dateModified" datetime="2024-01-07T00:14:38+08:00">2024-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>各种算法可视化网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</code></p>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><ol>
<li>顺序查找<br><code>基本思路：</code>从第一个元素开始逐个与需要查找的元素进行比较，当找到相同的元素时返回该元素的下标，否则返回-1.<br><code>复杂度分析：</code>查找成功时，平均查找长度ASL&#x3D;（n+1）&#x2F;2;查找不成功时，需要n+1次比较，故时间复杂度为O(n)<br><code>优点：</code>对表中数据元素的存储没有要求，另：对于线性表，只能顺序查找<br><code>缺点：</code>当n很大时，平均查找长度很大，效率低<br><code>代码实现：</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sequenceSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=arr.length-<span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">0</span>]=key;</span><br><span class="line">        <span class="keyword">while</span>(arr[n]!=key)&#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">43</span>;</span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[array.length+<span class="number">1</span>];</span><br><span class="line">        newArray[<span class="number">0</span>] = target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            newArray[i+<span class="number">1</span>] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sequenceSearch(newArray,target)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(result != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要查找的元素,在数组中的下标是：&quot;</span>+result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要查找的元素不在数组中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>折半查找（二分查找）<br><code>基本思路：</code>用给定值k先与中间节点的关键字比较，中间结点把线性表的分成两个子表，若相等则查找成功；不相等则再根据k与该中间结点关键字的比较结果求顶下一步查找哪个子表，一直递归进行。<br><code>复杂度分析：</code>时间复杂度：每次把搜索区域减少一半，时间复杂度为O(logn);空间复杂度：O(1)即存放k的空间<br><code>优点：</code>当表不频繁更新时，效率比较理想<br><code>缺点：</code>当表频繁更新时，维护表的有序将花费较大的精力<br><code>代码实现（递归和非递归）：</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> len,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;arr[mid])&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch2(arr,mid+<span class="number">1</span>,right,target);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch2(arr,left,mid-<span class="number">1</span>,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> array[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> result1=binarySearch1(array,<span class="number">9</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> result2=binarySearch2(array,<span class="number">0</span>,<span class="number">8</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;递归方法：要查找的元素在数组中的下标为&quot;</span>+result1);</span><br><span class="line">        System.out.println(<span class="string">&quot;非递归方法：要查找的元素在数组中的下标为：&quot;</span>+result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>索引查找（分块查找）<br><code>基本思路：</code>结合了顺序查找和折半查找，1.把数据分成n小块，要求第k块中的所有关键字都小于k+1块中的任意关键字；2.给每一块创建对象单独存到索引表；3.查找数据时先通过折半查找在索引表查当前数据属于哪一块；4.再到对应的块中顺序查找（块内无序，块间有序）<br><code>复杂度分析：</code>时间：O(logn)；空间O(n)<br><code>优点：</code>在表中插入和删除元素时，只需要找到对应的块，适合线性表既要快速查找又要经常改动的场景<br><code>缺点：</code>需要增加一个索引表的空间，需要对初始的索引表按照最大&#x2F;最小关键字进行排序和运算<br><code>代码实现：</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BlockTable</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;<span class="comment">//最大关键字</span></span><br><span class="line">        <span class="type">int</span> low;<span class="comment">//起始下标</span></span><br><span class="line">        <span class="type">int</span> high;<span class="comment">//结束下标</span></span><br><span class="line"></span><br><span class="line">        BlockTable(<span class="type">int</span> key, <span class="type">int</span> low, <span class="type">int</span> high) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.low = low;</span><br><span class="line">            <span class="built_in">this</span>.high = high;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner input=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//原表</span></span><br><span class="line">        <span class="type">int</span> a[]=&#123;<span class="number">9</span>,<span class="number">22</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">35</span>,<span class="number">42</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">48</span>,<span class="number">60</span>,<span class="number">58</span>,<span class="number">47</span>,<span class="number">78</span>,<span class="number">80</span>,<span class="number">77</span>,<span class="number">82</span>&#125;;</span><br><span class="line">        <span class="comment">//分块获得对应的索引表</span></span><br><span class="line">        BlockTable [] arr=&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BlockTable</span>(<span class="number">22</span>,<span class="number">0</span>,<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BlockTable</span>(<span class="number">44</span>,<span class="number">4</span>,<span class="number">7</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BlockTable</span>(<span class="number">60</span>,<span class="number">8</span>,<span class="number">11</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BlockTable</span>(<span class="number">82</span>,<span class="number">12</span>,<span class="number">15</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//打印原表</span></span><br><span class="line">        System.out.print(<span class="string">&quot;原表元素如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你所要查询的关键字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> key=input.nextInt();</span><br><span class="line">        <span class="type">int</span> result=BlockSearch(a,arr,key);</span><br><span class="line">        System.out.print(<span class="string">&quot;查询结果为：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">BlockSearch</span><span class="params">(<span class="type">int</span> a[],BlockTable[] arr,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//利用折半查找法查找元素所在的块</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid].key&gt;=key)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，元素所在的块为right+1 取对应左区间下标作为循环的开始点</span></span><br><span class="line">        <span class="type">int</span> i=arr[right+<span class="number">1</span>].low;</span><br><span class="line">        <span class="comment">//在块内进行顺序查找确定记录的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=arr[right+<span class="number">1</span>].high&amp;&amp;a[i]!=key)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果下标在块的范围之内，说明查找成功，否则失败</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=arr[right+<span class="number">1</span>].high)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>哈希查找<br><code>哈希表：</code>哈希表也叫散列表，是一种数据结构，它通过哈希函数将键映射到数组的特定位置，从而实现快速的数据检索。哈希表的基本思想是利用一个哈希函数将键映射到数组的索引，然后将值存储在该索引处。<br><code>构造哈希表：</code>除留余数法、平分取中法、随机数法、数字分析法等。<br><code>解决哈希冲突的方法：</code><br>1.链地址法：这是最常见的解决哈希冲突的方法。在每个哈希表位置（桶）上维护一个链表（或其他数据结构，如红黑树），所有映射到该位置的键值对都存储在链表中。当发生冲突时，新的键值对可以被添加到链表的末尾。链地址法简单且易于实现，适用于大多数应用。<br>2.开放地址法：在发生冲突时，通过一系列的探测方法（例如线性探测、二次探测、双重散列等）在哈希表中寻找下一个可用的位置，直到找到一个空闲的位置。开放地址法不使用额外的数据结构存储冲突的键值对，而是直接存储在哈希表的桶中。这种方法对于存储密集型的应用可能更有效，但在负载因子（键值对数量&#x2F;桶或数组数量）较高时容易产生聚集。<br>链地址法适用于插入和删除频繁的情况，而开放地址法适用于空间效率要求高、负载因子较低的情况。在实际应用中，链地址法更为常见。<br><code>代码实现：</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//哈希函数，这里用余数法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span>[] hashTable,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data%hashTable.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用开放地址法解决哈希冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertHashTable</span><span class="params">(<span class="type">int</span>[] hashTable,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> hashAddress=hash(hashTable,target);</span><br><span class="line">        <span class="keyword">while</span> (hashTable[hashAddress]!=<span class="number">0</span>)&#123;</span><br><span class="line">            hashAddress=(++hashAddress)%hashTable.length;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[hashAddress]=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchHashTable</span><span class="params">(<span class="type">int</span>[] hashTable,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> hashAddress=hash(hashTable,target);</span><br><span class="line">        <span class="keyword">while</span>(hashTable[hashAddress]!=target)&#123;</span><br><span class="line">            hashAddress=(++hashAddress%hashTable.length);</span><br><span class="line">            <span class="keyword">if</span>(hashTable[hashAddress]==<span class="number">0</span>||hashAddress==hash(hashTable,target))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHashTable</span><span class="params">(<span class="type">int</span>[] hashTable)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hashTable.length;i++)</span><br><span class="line">            System.out.print(hashTable[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array=&#123;<span class="number">13</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">76</span>,<span class="number">87</span>,<span class="number">45</span>,<span class="number">85</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        <span class="type">int</span> hashLength=<span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span>[] hashTable=<span class="keyword">new</span> <span class="title class_">int</span>[hashLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            insertHashTable(hashTable,array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;哈希表：&quot;</span>);</span><br><span class="line">        printHashTable(hashTable);</span><br><span class="line">        <span class="type">int</span> target=<span class="number">40</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;要查找的数据：&quot;</span>+target);</span><br><span class="line">        <span class="type">int</span> result=searchHashTable(hashTable,target);</span><br><span class="line">        <span class="keyword">if</span>(result==-<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;没有结果&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中的位置是：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol>
<li><strong>双亲表示法</strong><br>在每个结点中保存指向双亲的指针（一般是数组下标）<br><img src="https://img-blog.csdnimg.cn/20210222174500547.png#pic_center" alt="image">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">&#125;PNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTree</span>&#123;</span></span><br><span class="line">	PNode ndoes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>采用数组形式时，把根结点固定存在数组下标为0的位置，并且用-1表示没有父结点；</li>
<li>删除元素时，将该结点的双亲指针设为-1，结点数n–；或者把尾部数据移到前面，填充要删除的元素，最后n–。后者要更优。</li>
<li>如果删掉一颗子树，要将这棵子树的所有结点都删掉。</li>
<li>双亲表示法用来查询指定结点的双亲很简单，但是查找孩子结点只能从头到尾遍历对比。</li>
</ul>
<ol start="2">
<li><strong>孩子表示法（顺序+链式）</strong><br>顺序存储各个结点，每个结点中保存孩子链表的头指针。<br><img src="https://img-blog.csdnimg.cn/20210222180209672.png#pic_center" alt="image"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> child;<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;CNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	CNode* firstchild;</span><br><span class="line">&#125;CBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTree</span>&#123;</span></span><br><span class="line">	CBox ndoes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n,r;<span class="comment">//结点数,根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>各个结点的实际数据使用CBox存储</li>
<li>链表中的结点CNode只保存了每个孩子在数组中的下标</li>
</ul>
<ol start="3">
<li><strong>孩子兄弟表示法</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	CSNode* firstchild, * nextsibling;</span><br><span class="line">&#125;CSNode;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这种存储方法和二叉链表相似</li>
<li>可以把*firstchild看作*lchild，把*nextsibling看作*rchild</li>
</ul>
<ol start="4">
<li><strong>森林和树的转换</strong></li>
</ol>
<ul>
<li>森林转二叉树：先将森林中的各棵树转换为二叉树，在依次将各棵树的根结点看作兄弟关系。</li>
<li>二叉树转森林：左边为孩子，右边为兄弟</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>结点和创建方法示例(遍历方法中所使用的)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* rchild;</span><br><span class="line">&#125;Node,*Pointer;</span><br><span class="line"><span class="function">Pointer <span class="title">CreatLink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	Pointer p;</span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">	temp = <span class="built_in">getchar</span>();<span class="comment">//吸收空格</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="comment">//数据为-1时表示该结点为叶子</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		p = (Pointer)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		p-&gt;data = data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入%d的左子树：&quot;</span>, data);</span><br><span class="line">		p-&gt;lchild = <span class="built_in">CreatLink</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入%d的右子树：&quot;</span>, data);</span><br><span class="line">		p-&gt;rchild = <span class="built_in">CreatLink</span>();</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四种遍历方法"><a href="#四种遍历方法" class="headerlink" title="四种遍历方法"></a>四种遍历方法</h4><ol>
<li><strong>先序遍历（Preorder Traversal）</strong><br>顺序为：根-&gt;左子树-&gt;右子树<br>可以想象为从根结点出发，逆时针绕着树跑一圈</li>
</ol>
<ul>
<li>递归方法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">preorder</span><span class="params">(Pointer p)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);<span class="comment">//访问根结点</span></span><br><span class="line">	preorder(p-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">	preorder(p-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>非递归方法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.访问根结点，将根结点入栈</span></span><br><span class="line"><span class="comment">//2.循环访问左子树，入栈，当没有左子树的时候跳出循环</span></span><br><span class="line"><span class="comment">//3.栈不为空的时候根结点出栈，访问右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder2</span><span class="params">(Pointer p)</span> </span>&#123;</span><br><span class="line">	std::stack&lt;Pointer&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">			s.<span class="built_in">push</span>(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (！s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>中序遍历（Inorder Traversal）</strong><br>顺序为：左子树-&gt;根结点-&gt;右子树<br>可以看作每个结点垂直方向投射下来，从左往右读</li>
</ol>
<ul>
<li>递归方法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Pointer p)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	inorder(p-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);<span class="comment">//访问根结点</span></span><br><span class="line">	inorder(p-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>非递归方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.将根结点入栈</span></span><br><span class="line"><span class="comment">//2.循环访问左子树，入栈，当没有左子树时，跳出循环</span></span><br><span class="line"><span class="comment">//3.栈不为空时，根结点出栈，访问根结点，再访问右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder2</span><span class="params">(Pointer p)</span> </span>&#123;</span><br><span class="line">	std::stack&lt;Pointer&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>||!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			p = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>后序遍历（Postorder Traversal）</strong><br>顺序为：左子树-&gt;右子树-&gt;根结点<br>可以看作从根结点逆时针绕圈，但只能单个地取下</li>
</ol>
<ul>
<li>递归方法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postorder</span><span class="params">(Pointer p)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	postorder(p-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">	postorder(p-&gt;rchild);<span class="comment">//递归遍历右子树	</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);<span class="comment">//访问根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>非递归方法<br>由于根结点在孩子结点之后访问，当先遍历左子树时，要记录右子树是否访问过，这也是后序遍历和以上两种方法最大的区别<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder2</span><span class="params">(Pointer p)</span> </span>&#123;</span><br><span class="line">	std::stack&lt;Pointer&gt; s;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Pointer current = p;</span><br><span class="line">	Pointer lastVisited = <span class="literal">NULL</span>;<span class="comment">//根结点要在左右孩子都访问之后才能访问，如果先遍历左子树的话，需要记录右子树是否访问</span></span><br><span class="line">	<span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(current);</span><br><span class="line">			current = current-&gt;lchild;</span><br><span class="line">		&#125;<span class="comment">//遍历到没有左孩子的结点</span></span><br><span class="line">		Pointer top = s.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span> (top-&gt;rchild == <span class="literal">NULL</span> || top-&gt;rchild == lastVisited) &#123;<span class="comment">//如果根结点的右子树为空或者访问过就访问根结点</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, top-&gt;data);</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			lastVisited = top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			current = top-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p><strong>层序遍历（Level Order Traversal）</strong><br>按树的层次从左到右访问<br>层序遍历中，从根结点开始逐层遍历，先访问的结点后面不再用到，恰好符合队列先进先出的特点，所以借助队列来存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">(Pointer p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	std::queue&lt;Pointer&gt; Queue;</span><br><span class="line">	Queue.<span class="built_in">push</span>(p);</span><br><span class="line">	<span class="keyword">while</span> (!Queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Pointer front = Queue.<span class="built_in">front</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, front-&gt;data);</span><br><span class="line">		Queue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (front-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Queue.<span class="built_in">push</span>(front-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (front-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Queue.<span class="built_in">push</span>(front-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行示例</strong><br><img src="https://img-blog.csdnimg.cn/337b730e1f2b41aeac150763f10256e4.png" alt="图"><br>（0-9对应A-J）<br>输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pointer p = <span class="built_in">CreatLink</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;先序：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">preorder</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">preorder2</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;中序：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">inorder</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">inorder2</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;后序：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">postorder</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">postorder2</span>(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;层序：&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">levelorder</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预期结果：<br>先序：0136782495<br>中序：6387104925<br>后序：6873194520<br>层序：0123456798<br>运行结果  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">先序：</span><br><span class="line"><span class="number">0136782495</span></span><br><span class="line"><span class="number">0136782495</span></span><br><span class="line">中序：</span><br><span class="line"><span class="number">6387104925</span></span><br><span class="line"><span class="number">6387104925</span></span><br><span class="line">后序：</span><br><span class="line"><span class="number">6873194520</span></span><br><span class="line"><span class="number">6873194520</span></span><br><span class="line">层序：</span><br><span class="line"><span class="number">0123456798</span></span><br></pre></td></tr></table></figure>
<p>符合预期</p>
</li>
</ol>
<h4 id="二叉树的变形"><a href="#二叉树的变形" class="headerlink" title="二叉树的变形"></a>二叉树的变形</h4><ol>
<li>AVL树<br>得名于它的发明者——苏联的数学家Georgy Adelson-Velsky和Evgenii Landis<br>当搜索二叉树出现每个结点至多有一个孩子的情况时，搜索的效率甚至比链表还低，搜索二叉树基础上出现的AVL树（平衡二叉树）就解决了这样的问题，当平衡二叉树的某个结点左右子树的高度差的绝对值大于一时，就会通过旋转操作减小高度差。<br><code>特点：</code>是二叉搜索树；每个结点的左右子树的高度差绝对值（平衡因子）最大为1；当插入或删除一个结点时，导致某一个结点的平衡因子大于1，就需要通过左旋和右旋使二叉树再次达到平衡状态。<br>avl树的旋转分四种情况：<br>1.在右子树的右子树上插入结点，导致不平衡：左旋<br>2.在左子树的左子树上插入结点，导致不平衡：右旋<br>3.在左子树的右子树上插入结点，导致不平衡：先对左子树左旋再对整棵树右旋<br>4.在右子树的左子树上插入结点，导致不平衡：先对右子树右旋再对整棵树左旋<br>示例代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">avlTree</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        E value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.value=value;</span><br><span class="line">            height=<span class="number">1</span>;</span><br><span class="line">            left=<span class="literal">null</span>;</span><br><span class="line">            right=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.print(<span class="built_in">this</span>.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBalanceFactor(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root.left)-getHeight(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalance</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> balanceFactor=Math.abs(getBalanceFactor(node.left)-getBalanceFactor(node.right));</span><br><span class="line">        <span class="keyword">if</span>(balanceFactor&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalance(node.left)&amp;&amp;isBalance(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalance(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inPreOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        inPreOrder(root.left);</span><br><span class="line">        root.print();</span><br><span class="line">        inPreOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inPreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;中序遍历结果：&quot;</span>);</span><br><span class="line">        inPreOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋方法，返回根结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;leftRotate&quot;</span>);</span><br><span class="line">        Node cur=node.right;</span><br><span class="line">        node.right=cur.left;</span><br><span class="line">        cur.left=node;</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        node.height=Math.max(getHeight(node.left),getHeight(node.right))+<span class="number">1</span>;</span><br><span class="line">        cur.height=Math.max(getHeight(cur.left),getHeight(cur.right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右旋方法，返回根结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rightRotate&quot;</span>);</span><br><span class="line">        Node cur=node.left;</span><br><span class="line">        node.left=cur.right;</span><br><span class="line">        cur.right=node;</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        node.height=Math.max(getHeight(node.left),getHeight(node.right))+<span class="number">1</span>;</span><br><span class="line">        cur.height=Math.max(getHeight(cur.left),getHeight(cur.right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        root = add(root,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">add</span><span class="params">(Node node, E value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value.compareTo(node.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = add(node.right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.compareTo(node.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = add(node.left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点高度</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取当前节点的平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在左子树的左子树上，此时需要进行右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在右子树子树的右子树上，此时需要进行左旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在左子树的右子树上，此时需要先对左子树左旋，在整个树右旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.left) &gt; 0</span></span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在右子树的左子树上，此时需要先对右子树右旋，再整个树左旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(E value)</span>&#123;</span><br><span class="line">        root = remove(root,value);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(Node node, E value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">retNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> retNode;</span><br><span class="line">        <span class="keyword">if</span>(value.compareTo(node.value) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = remove(node.right,value);</span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value.compareTo(node.value) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = remove(node.left,value);</span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//value.compareTo(node.value) = 0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//左右节点都为空，或者左节点为空</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                size--;</span><br><span class="line">                retNode = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右节点为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                size--;</span><br><span class="line">                retNode = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左右节点都不为空</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                <span class="comment">//寻找右子树最小的节点</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                successor.value  = cur.value;</span><br><span class="line">                successor.right = remove(node.right,value);</span><br><span class="line">                successor.left = node.left;</span><br><span class="line">                node.left =  node.right = <span class="literal">null</span>;</span><br><span class="line">                retNode = successor;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(retNode == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//维护二叉树平衡</span></span><br><span class="line">            <span class="comment">//跟新height</span></span><br><span class="line">            retNode.height = Math.max(getHeight(retNode.left),getHeight(retNode.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(retNode);</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在左子树的左子树上，此时需要进行右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在右子树子树的右子树上，此时需要进行左旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在左子树的右子树上，此时需要先对左子树左旋，在整个树右旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.left = leftRotate(retNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该子树不平衡且新插入节点(导致不平衡的节点)在右子树的左子树上，此时需要先对右子树右旋，再整个树左旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.right = rightRotate(retNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  retNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
测试代码（这里仅以往右子树的左子树上插入结点导致不平衡为例）：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        avlTree&lt;Integer&gt; avlTree=<span class="keyword">new</span> <span class="title class_">avlTree</span>&lt;&gt;();</span><br><span class="line">        avlTree.root=avlTree.<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">20</span>);</span><br><span class="line">        avlTree.add(<span class="number">15</span>);</span><br><span class="line">        avlTree.add(<span class="number">50</span>);</span><br><span class="line">        avlTree.add(<span class="number">40</span>);</span><br><span class="line">        avlTree.add(<span class="number">70</span>);</span><br><span class="line">        avlTree.add(<span class="number">35</span>);</span><br><span class="line">        avlTree.inPreOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
运行结果：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中序遍历结果：<span class="number">15</span> <span class="number">20</span> <span class="number">35</span> <span class="number">40</span> <span class="number">50</span> <span class="number">70</span> </span><br></pre></td></tr></table></figure></li>
<li>哈夫曼树（Huffman Tree）<br>哈夫曼编码是一种统计编码，属于无损压缩编码，对于出现频率较高的字符，编码的长度较短，堆出现频率较低的，编码的长度较长。<br>哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。<br>哈夫曼编码实现步骤：<br>1.统计：读入要压缩的源文件，统计字符出现的次数<br>2.建树：构建哈夫曼树<br>3.编码：对哈夫曼树的左边记为0，右边记为1，就可以得到字符的哈夫曼编码<br>4.输出：把编码序列输出，这就是压缩后的数据<br>解码实现步骤：<br>1.读取码表的信息，构建出码表<br>2.读回具体的数据内容<br>3.把读回的字节还原成对应的整型数据<br>4.根据码表，把内容组成的哈夫曼树编码，依次转换回原始的字符，得到原始内容<br>利用哈夫曼编码实现简单的文件压缩和解压：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decompress</span><span class="params">(String fileName,String newfile)</span>&#123;</span><br><span class="line"></span><br><span class="line">        DataInputStream in=<span class="literal">null</span>;</span><br><span class="line">        String srcContent=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in=<span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(fileName)));</span><br><span class="line">            <span class="comment">//      1. 读取码表的信息，构建出码表</span></span><br><span class="line">            Map&lt;String,String&gt; map=readCodes(in);</span><br><span class="line">            <span class="comment">//      2. 读回具体的数据内容</span></span><br><span class="line">            <span class="type">byte</span>[] datas=<span class="built_in">this</span>.readDatas(in);</span><br><span class="line">            <span class="comment">//      3. 把读回的字节还原成对应的整型数据</span></span><br><span class="line">            <span class="type">int</span>[] dataInts=<span class="built_in">this</span>.bytetoIntArray(datas);</span><br><span class="line">            <span class="comment">//      4. 根据码表，把内容组成的哈夫曼树编码，依次转换回原始的字符，得到原始内容</span></span><br><span class="line">            srcContent=<span class="built_in">this</span>.HuffmanChar(map,dataInts);</span><br><span class="line">            <span class="comment">//      5. 将内容写进文件</span></span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(newfile));</span><br><span class="line">            writer.write(srcContent);</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把Huffman编码转为原始的内容</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">HuffmanChar</span><span class="params">(Map&lt;String,String&gt; map,<span class="type">int</span>[] dataInts)</span>&#123;</span><br><span class="line">        StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//1.把整形数组还原成为对应的字符串，也就是Huffman编码串</span></span><br><span class="line">        String str=<span class="built_in">this</span>.intToBinaryString(dataInts);</span><br><span class="line">        <span class="comment">//2.把Huffman编码串依次替换回字符</span></span><br><span class="line">        <span class="keyword">while</span> (str.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String code:map.keySet())&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.startsWith(code))&#123;</span><br><span class="line">                    buffer.append(map.get(code));</span><br><span class="line">                    str=str.substring(code.length());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把int值转换回对应的二进制编码表示的字符串</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">intToBinaryString</span><span class="params">(<span class="type">int</span>[] as)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=as.length;</span><br><span class="line">        <span class="comment">//用数组存放每个byte对应的二进制字符串</span></span><br><span class="line">        String[] ss=<span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">        String binaryStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//得到每个整数对应的二进制字符串</span></span><br><span class="line">            ss[i]=Integer.toBinaryString(as[i]);</span><br><span class="line">            ss[i]=<span class="built_in">this</span>.addZero(ss[i]);</span><br><span class="line">            binaryStr+=ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理尾部原来补的零</span></span><br><span class="line">        <span class="type">int</span> zeros=as[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(zeros&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            binaryStr=binaryStr.substring(<span class="number">0</span>,binaryStr.length()-zeros);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binaryStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给每个二进制字符串补足八位</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">addZero</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&lt;<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="type">int</span> zeroNum=<span class="number">8</span>-str.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zeroNum;i++)&#123;</span><br><span class="line">                str=<span class="string">&quot;0&quot;</span>+str;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bytetoIntArray(<span class="type">byte</span>[] datas)&#123;</span><br><span class="line">        <span class="type">int</span>[] as=<span class="keyword">new</span> <span class="title class_">int</span>[datas.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;datas.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(datas[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                as[i]=datas[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                as[i]=datas[i]+<span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> as;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] readDatas(DataInputStream in) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//读回有多少个byte</span></span><br><span class="line">        <span class="type">int</span> dataByteNum=in.readInt();</span><br><span class="line">        <span class="comment">//2.创建出byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs=<span class="keyword">new</span> <span class="title class_">byte</span>[dataByteNum];</span><br><span class="line">        <span class="comment">//3.循环把每个byte读取回来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dataByteNum;i++)&#123;</span><br><span class="line">            bs[i] =in.readByte();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map.key是编码，value是字符</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">readCodes</span><span class="params">(DataInputStream in)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//1.读回编码个数</span></span><br><span class="line">        <span class="type">int</span> codeNum=in.readInt();</span><br><span class="line">        <span class="comment">//2.读回每个字符、编码长度、Huffman编码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;codeNum;i++)&#123;</span><br><span class="line">            <span class="type">char</span> codeChar=in.readChar();</span><br><span class="line">            <span class="type">int</span> codeLen=in.readInt();</span><br><span class="line">            String code=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span>[] cs=<span class="keyword">new</span> <span class="title class_">char</span>[codeLen];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cs.length;j++)&#123;</span><br><span class="line">                code+=in.readChar();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(code,<span class="string">&quot;&quot;</span>+codeChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compress</span><span class="params">(String str,String outFile)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计</span></span><br><span class="line">        PriorityQueue queue=<span class="built_in">this</span>.statistics(str);</span><br><span class="line">        <span class="comment">//建树</span></span><br><span class="line">        HuffmanNode tree=<span class="built_in">this</span>.buidHuffmantree(queue);</span><br><span class="line">        <span class="comment">//编码</span></span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="built_in">this</span>.buildHuffmanCode(map,tree,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="built_in">this</span>.outData(str,map,outFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue <span class="title function_">statistics</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//1.统计次数</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">char</span>[] cs=str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:cs)&#123;</span><br><span class="line">            Object obj=map.get(c);</span><br><span class="line">            <span class="keyword">if</span>(obj==<span class="literal">null</span>)&#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(c,((Integer)obj)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.构建优先队列</span></span><br><span class="line">        PriorityQueue queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(map.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:map.keySet())&#123;</span><br><span class="line">            HuffmanNode node=<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(c,map.get(c));</span><br><span class="line">            queue.insert(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> HuffmanNode <span class="title function_">buidHuffmantree</span><span class="params">(PriorityQueue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//1.先取两个最小权重的对象</span></span><br><span class="line">            <span class="type">HuffmanNode</span> <span class="variable">n1</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="type">HuffmanNode</span> <span class="variable">n2</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="comment">//2.构建这两个对象的父对象</span></span><br><span class="line">            <span class="type">HuffmanNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuffmanNode</span>((<span class="type">char</span>) <span class="number">0</span>, n1.getCount() + n2.getCount());</span><br><span class="line">            n3.setLeftchild(n1);</span><br><span class="line">            n3.setRightchild(n2);</span><br><span class="line">            <span class="comment">//3.把父对象放回优先队列</span></span><br><span class="line">            queue.insert(n3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.peekFront();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildHuffmanCode</span><span class="params">(Map&lt;String,String&gt; map,HuffmanNode tree,String zero_one)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.树没有子节点</span></span><br><span class="line">        <span class="keyword">if</span>(tree.getLeftchild()==<span class="literal">null</span>&amp;&amp;tree.getRightchild()==<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(<span class="string">&quot;&quot;</span>+tree.getC(),zero_one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.有左子节点</span></span><br><span class="line">        <span class="keyword">if</span>(tree.getLeftchild()!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.buildHuffmanCode(map,tree.getLeftchild(),zero_one+<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.有右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(tree.getRightchild()!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.buildHuffmanCode(map,tree.getRightchild(),zero_one+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出数据到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outData</span><span class="params">(String str,Map&lt;String,String&gt; map,String outFileName)</span>&#123;</span><br><span class="line">        File outFile=<span class="keyword">new</span> <span class="title class_">File</span>(outFileName);</span><br><span class="line">        DataOutputStream os=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            os=<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outFile));</span><br><span class="line">            <span class="comment">//1.输出码表</span></span><br><span class="line">            <span class="built_in">this</span>.outCodes(os,map);</span><br><span class="line">            <span class="comment">//2.输出原内容的每个字符对应的Huffman编码</span></span><br><span class="line">            String dataHuffmanCode=<span class="built_in">this</span>.sourceHuffman(str,map);</span><br><span class="line">            <span class="built_in">this</span>.outDataHuffmanCode(os,dataHuffmanCode);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出原始内容转换为Huffman编码串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outDataHuffmanCode</span><span class="params">(DataOutputStream os, String dataHuffmanCode)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.要将Huffman编码串转换成为对应的byte[]</span></span><br><span class="line">        <span class="type">byte</span>[] bs=<span class="built_in">this</span>.stringtoByteArrays(dataHuffmanCode);</span><br><span class="line">        <span class="comment">//2.输出byte数组的个数</span></span><br><span class="line">        os.writeInt(bs.length);</span><br><span class="line">        <span class="comment">//3.输出byte数组</span></span><br><span class="line">        os.write(bs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把一个内容是二进制编码的串转换为真正的二进制数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] stringtoByteArrays(String dataHuffmanCode)&#123;</span><br><span class="line">        <span class="type">byte</span>[] retBytes=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] cs=dataHuffmanCode.toCharArray();</span><br><span class="line">        <span class="type">int</span> len=cs.length;</span><br><span class="line">        <span class="type">int</span> lenByte=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.判断整个串的长度是否能被8整除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">8</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 2.能被8整除就八位作一个byte</span></span><br><span class="line">            lenByte=len/<span class="number">8</span>+<span class="number">1</span>;<span class="comment">//最后要存放补零的个数</span></span><br><span class="line">            retBytes=<span class="keyword">new</span> <span class="title class_">byte</span>[lenByte];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenByte-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                String s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">8</span>;j&lt;(i+<span class="number">1</span>)*<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    s+=cs[j];</span><br><span class="line">                &#125;</span><br><span class="line">                retBytes[i]=<span class="built_in">this</span>.chartoByte(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置补零的个数</span></span><br><span class="line">            retBytes[lenByte-<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.不能的话最后一个字符串后面补0，作为一个byte，同时寄了补零的个数</span></span><br><span class="line">            lenByte=len/<span class="number">8</span>+<span class="number">2</span>;</span><br><span class="line">            retBytes=<span class="keyword">new</span> <span class="title class_">byte</span>[lenByte];</span><br><span class="line">            <span class="type">int</span> zeroNum=<span class="number">8</span>-len%<span class="number">8</span>;</span><br><span class="line">            <span class="comment">//补零</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zeroNum;i++)&#123;</span><br><span class="line">                dataHuffmanCode+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新计算char数组</span></span><br><span class="line">            cs=dataHuffmanCode.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenByte-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                String s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">8</span>;j&lt;(i+<span class="number">1</span>)*<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    s+=cs[j];</span><br><span class="line">                &#125;</span><br><span class="line">                retBytes[i]=<span class="built_in">this</span>.chartoByte(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置补零的个数</span></span><br><span class="line">            retBytes[lenByte-<span class="number">1</span>]=(<span class="type">byte</span>) zeroNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把一个字符串转换为byte</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> <span class="title function_">chartoByte</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] cs=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cs.length;i++)&#123;</span><br><span class="line">            <span class="comment">//计算每一位char代表的真正byte值</span></span><br><span class="line">            <span class="type">byte</span> tempB=(<span class="type">byte</span>) (Byte.parseByte(<span class="string">&quot;&quot;</span>+cs[i])*Math.pow(<span class="number">2</span>,cs.length-i-<span class="number">1</span>));</span><br><span class="line">            ret=(<span class="type">byte</span>)(ret+tempB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把原始内容转换成Huffman编码串</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">sourceHuffman</span><span class="params">(String str, Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">char</span>[] cs=str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:cs)&#123;</span><br><span class="line">            buffer.append(map.get(<span class="string">&quot;&quot;</span>+c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出码表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outCodes</span><span class="params">(DataOutputStream os,Map&lt;String,String&gt; map)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.输出码的个数</span></span><br><span class="line">        os.writeInt(map.size());</span><br><span class="line">        <span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">            <span class="comment">//2.输出每个字符以及编码的长度</span></span><br><span class="line">            os.writeChar(key.charAt(<span class="number">0</span>));</span><br><span class="line">            os.writeInt(map.get(key).length());</span><br><span class="line">            <span class="comment">//3.输出每个字符对应的Huffman编码</span></span><br><span class="line">            os.writeChars(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读文件</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readFile</span><span class="params">(String fileName)</span>&#123;</span><br><span class="line">        StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        DataInputStream in=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in=<span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(fileName)));</span><br><span class="line">            String tempStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tempStr=in.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                buffer.append(tempStr+=<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        HuffmanTree t=<span class="keyword">new</span> <span class="title class_">HuffmanTree</span>();</span><br><span class="line"><span class="comment">//        t.compress(&quot;aaabbddddd&quot;);</span></span><br><span class="line">       <span class="comment">//t.compress(t.readFile(&quot;D:\\HuaweiMoveData\\Users\\86191\\Desktop\\test.txt&quot;),&quot;D:\\HuaweiMoveData\\Users\\86191\\Desktop\\temp.myzip&quot;);</span></span><br><span class="line">        String in=sc.next();</span><br><span class="line">        <span class="keyword">if</span>(in.equals(<span class="string">&quot;压缩&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入需要压缩文件的地址：&quot;</span>);</span><br><span class="line">            String location=sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入压缩文件的存储位置：&quot;</span>);</span><br><span class="line">            String newfile=sc.next();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            t.compress(t.readFile(location),newfile);</span><br><span class="line">            System.out.println(<span class="string">&quot;已保存&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件路径错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(in.equals(<span class="string">&quot;解压缩&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入需要解压缩的文件的地址：&quot;</span>);</span><br><span class="line">            String location=sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入保存新文件的地址：&quot;</span>);</span><br><span class="line">            String newfile=sc.next();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                t.decompress(location,newfile);</span><br><span class="line">                System.out.println(<span class="string">&quot;已保存&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件路径错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入正确的指令&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
优先队列PriorityQueue类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HuffmanNode[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nItems;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.length=length;</span><br><span class="line">        nItems=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(HuffmanNode data)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nItems==<span class="number">0</span>)&#123;</span><br><span class="line">            queue[nItems]=data;</span><br><span class="line">            nItems++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=nItems-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data.getCount()&lt;queue[i].getCount())&#123;</span><br><span class="line">                    queue[i+<span class="number">1</span>]=queue[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue[i+<span class="number">1</span>]=data;</span><br><span class="line">            nItems++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HuffmanNode <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">        nItems--;</span><br><span class="line">        HuffmanNode temp=queue[nItems];</span><br><span class="line">        queue[nItems]=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HuffmanNode <span class="title function_">peekFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue[nItems-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nItems==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nItems==queue.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(HuffmanNode d:queue)&#123;</span><br><span class="line">            System.out.println(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue t=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">5</span>);</span><br><span class="line">        t.insert(<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">5</span>));</span><br><span class="line">        t.insert(<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">6</span>));</span><br><span class="line">        t.insert(<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>));</span><br><span class="line">        t.insert(<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(<span class="string">&#x27;d&#x27;</span>,<span class="number">4</span>));</span><br><span class="line">        t.insert(<span class="keyword">new</span> <span class="title class_">HuffmanNode</span>(<span class="string">&#x27;e&#x27;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        t.printQueue();</span><br><span class="line">        HuffmanNode ret=t.peekFront();</span><br><span class="line">        System.out.println(<span class="string">&quot;now ret:&quot;</span>+ret);</span><br><span class="line">        t.remove();</span><br><span class="line">        HuffmanNode ret2=t.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;now ret2:&quot;</span>+ret2);</span><br><span class="line">        t.printQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
哈夫曼树结点HuffmanNode类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> c;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;<span class="comment">//出现的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HuffmanNode leftchild;</span><br><span class="line">    <span class="keyword">private</span> HuffmanNode rightchild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HuffmanNode</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HuffmanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;c=&quot;</span> + c +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&quot;, leftchild=&quot;</span> + leftchild +</span><br><span class="line">                <span class="string">&quot;, rightchild=&quot;</span> + rightchild +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setC</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HuffmanNode <span class="title function_">getLeftchild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftchild</span><span class="params">(HuffmanNode leftchild)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftchild = leftchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HuffmanNode <span class="title function_">getRightchild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightchild</span><span class="params">(HuffmanNode rightchild)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightchild = rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆（待补充）<br>**<code>堆：</code>**如果有一个关键码的集合K，把它的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足Ki&lt;&#x3D;K2i+1且Ki&lt;&#x3D;K2i+2（或大于等于），则称为小堆（或大堆），根结点最小的叫小根堆或最小堆，最大的叫大根堆或最大堆。<br><code>性质：</code>堆中某个节点的值总是不大于或者不小于其父节点的值；堆总是一颗完全二叉树。<br><code>堆和栈的区别：</code><br>申请方式不同：栈由系统自动分配，堆是人为申请开辟<br>申请大小不同：栈获得的空间较小，堆获得的空间较大<br>申请效率不同：栈由系统自动分配，速度较快，堆一般速度较慢<br>存储内容（使用场景）不同：栈适用于需要快速分配和释放内存、局部变量生命周期明确定义的情况，常用于存储基本数据类型、对象引用等；堆适用于需要动态分配内存、生命周期不确定、大小不确定的情况，常用于存储复杂数据结构、大型对象等。<br>底层不同：栈是连续空间，堆是不连续空间<br>**<code>堆排序</code>**：<br>堆排序是利用堆这种数据结构而设计的一种排序算法，最好、最坏、平均时间复杂度均为O(nlongn)，它也是不稳定排序。<br>例：列出对n个数堆升序排序后的前m个数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.输入n个数</span></span><br><span class="line"><span class="comment">2.从n/2开始自下而上建堆，对每个父结点下滤down()（子节点小于父结点则交换，再递归调用down()）,得到小顶堆</span></span><br><span class="line"><span class="comment">3.输出堆顶的数据，再将最后一个数据和第一个交换，size-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//比较三个数当中的最小值 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line">	<span class="comment">//左子节点 （左子节点存在且左子节点小于父节点） </span></span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])</span><br><span class="line">		t = u * <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//右子节点 （右子节点存在且右子节点小于父节点） </span></span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">		t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (u != t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; h[i];</span><br><span class="line">	size = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i != <span class="number">0</span>; i--)</span><br><span class="line">		<span class="built_in">down</span>(i);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		h[<span class="number">1</span>] = h[size];</span><br><span class="line">		size--;</span><br><span class="line">		<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
测试输入：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">23</span> <span class="number">45</span> <span class="number">23</span> <span class="number">56</span> <span class="number">765</span> <span class="number">23</span> <span class="number">45</span> <span class="number">42</span> <span class="number">86</span></span><br></pre></td></tr></table></figure>
输出：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span> <span class="number">23</span> <span class="number">23</span> <span class="number">42</span> <span class="number">45</span> <span class="number">45</span> <span class="number">56</span> <span class="number">86</span> <span class="number">765</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>Graph类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; vertex;<span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">protected</span>  <span class="type">int</span>[][] edge;<span class="comment">//边</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span>[] isVisited;<span class="comment">//是否被访问</span></span><br><span class="line">    <span class="keyword">protected</span>  <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="built_in">this</span>.edge=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="built_in">this</span>.isVisited=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取结点个数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertex.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:vertex) System.out.print(<span class="string">&quot;  &quot;</span>+s);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;vertex.size();r++)&#123;</span><br><span class="line">            System.out.print(vertex.get(r)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertex.size();i++)&#123;</span><br><span class="line">                System.out.print(String.format(<span class="string">&quot;%2d&quot;</span>,edge[r][i])+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的数目</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumOfEdge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某条边的权值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getWeightOfEdges</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edge[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(String v)</span>&#123;</span><br><span class="line">        vertex.add(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2,<span class="type">int</span> weigeht)</span>&#123;</span><br><span class="line">        edge[v1][v2]=weigeht;</span><br><span class="line">        edge[v2][v1]=weigeht;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取顶点索引对应的值</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertex.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">example</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="number">7</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">        graph.addVertex(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">        graph.addEdge(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        graph.addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">        graph.addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">        graph.addEdge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例图的邻接矩阵：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   A  B  C  D  E  F  G</span><br><span class="line">A  <span class="number">0</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span> </span><br><span class="line">B  <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">9</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">3</span> </span><br><span class="line">C  <span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">0</span> </span><br><span class="line">D  <span class="number">0</span>  <span class="number">9</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span> </span><br><span class="line">E  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">4</span> </span><br><span class="line">F  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">6</span> </span><br><span class="line">G  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<h3 id="求最小生成树"><a href="#求最小生成树" class="headerlink" title="求最小生成树"></a>求最小生成树</h3><p>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。<br>应用：通信网络设计、电力输电网络、城市规划等。</p>
<h4 id="Kruskal算法（加边法）"><a href="#Kruskal算法（加边法）" class="headerlink" title="Kruskal算法（加边法）"></a>Kruskal算法（加边法）</h4><p>初始最小生成树的边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里面。<br>算法思想：</p>
<ol>
<li>把图中所有边按代价从小到大排列</li>
<li>把图中n个顶点看成独立的n棵树组成的森林</li>
<li>按权值从小到大选择边，所选的边连接的两个顶点属于两科不同的树（即不成环），则成为最小生成树的一条边，并将这两棵树合并作为一棵树</li>
<li>重复（3）直到所有的顶点都在一棵树内，或者有n-1条边为止</li>
</ol>
<ul>
<li>代码基本步骤：对边进行排序、把最小的边加入生成树、判断是否产生回路</li>
<li>代码的重点在于在加边时如何判断是否会成环，在上面的代码中，通过end数组来记录每个顶点的终点，每次加边都更新终点（由于在记录边的时候确保了v1的索引低于v2的索引，所以其实end是从孩子指向双亲的）<br>Kruskal算法代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[index] != <span class="number">0</span>) index = ends[index];</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[graph.getNumOfVertex()];<span class="comment">//存放顶点的终点信息</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放每次连接的路径</span></span><br><span class="line">        <span class="type">int</span>[][] edgeData = <span class="keyword">new</span> <span class="title class_">int</span>[graph.getNumOfEdge()][<span class="number">3</span>];<span class="comment">//将顶点存放在数组中，然后根据权值大小排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>; i &lt; graph.getNumOfVertex() &amp;&amp; count &lt; graph.getNumOfEdge(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; graph.getNumOfVertex(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph.edge[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeData[count][<span class="number">0</span>] = graph.edge[i][j];</span><br><span class="line">                    edgeData[count][<span class="number">1</span>] = i;</span><br><span class="line">                    edgeData[count][<span class="number">2</span>] = j;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edgeData, (e1, e2) -&gt; e1[<span class="number">0</span>] - e2[<span class="number">0</span>]);<span class="comment">//按第一列元素升序排列</span></span><br><span class="line">        <span class="comment">//检查是否有环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edgeData.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> getEnd(ends, edgeData[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> getEnd(ends, edgeData[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">                ends[v1] = v2;</span><br><span class="line">                result.add(<span class="string">&quot;&lt;&quot;</span> + graph.getValueByIndex(edgeData[i][<span class="number">1</span>]) + <span class="string">&quot;,&quot;</span> + graph.getValueByIndex(edgeData[i][<span class="number">2</span>]) + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;各顶点间的连接线：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String e : result) System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
运行结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">各顶点间的连接线：</span><br><span class="line">&lt;A,G&gt;</span><br><span class="line">&lt;B,G&gt;</span><br><span class="line">&lt;D,F&gt;</span><br><span class="line">&lt;E,G&gt;</span><br><span class="line">&lt;E,F&gt;</span><br><span class="line">&lt;A,C&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>注：G&#x3D;(V,E)是连通图，T&#x3D;(U,D)是最小生成树</p>
<ol>
<li>从集合V中取出顶点D放到集合U中，标记顶点的visited[u]&#x3D;1</li>
<li>若集合U中顶点与集合V中的顶点vj之间存在边，则寻找这些边中权值最小且不构成回路的，添加到U中，标记visited[vj]&#x3D;1</li>
<li>重复步骤1，直到U与V相等</li>
</ol>
<ul>
<li>代码的关键在于每次从周围吸收一条与之邻接且权值最小的边，以及相连的顶点，直到吸收完所有的顶点。<br>Prim算法代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(Graph graph,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放没每次添加的路径</span></span><br><span class="line">        List&lt;Integer&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放每次遍历到的顶点的索引</span></span><br><span class="line">        temp.add(v);<span class="comment">//先添加第一个点</span></span><br><span class="line">        graph.isVisited[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> minRoute=Integer.MAX_VALUE;<span class="comment">//最短边</span></span><br><span class="line">        <span class="type">int</span> nextVertex=<span class="number">0</span>;<span class="comment">//下个顶点的索引</span></span><br><span class="line">        <span class="type">int</span> curVertex=<span class="number">0</span>;<span class="comment">//当前顶点的索引</span></span><br><span class="line">        <span class="keyword">while</span> (temp.size()&lt;graph.getNumOfVertex())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.getNumOfVertex();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph.edge[temp.get(j)][i]!=<span class="number">0</span>&amp;&amp;!graph.isVisited[i]&amp;&amp;graph.edge[temp.get(j)][i]&lt;minRoute)&#123;</span><br><span class="line">                        minRoute=graph.edge[temp.get(j)][i];</span><br><span class="line">                        nextVertex=i;</span><br><span class="line">                        curVertex=temp.get(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//找到当前加入树中的顶点的最小边，确定下一个加入的顶点</span></span><br><span class="line">            graph.isVisited[nextVertex]=<span class="literal">true</span>;</span><br><span class="line">            minRoute=Integer.MAX_VALUE;<span class="comment">//重新设为最大值</span></span><br><span class="line">            temp.add(nextVertex);</span><br><span class="line">            result.add(<span class="string">&quot;&lt;&quot;</span>+graph.getValueByIndex(curVertex)+<span class="string">&quot;,&quot;</span>+graph.getValueByIndex(nextVertex)+<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;各顶点间的连线：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String e:result) System.out.println(e);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(Integer e:temp) System.out.print(graph.getValueByIndex(e)+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
运行结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">各顶点间的连线：</span><br><span class="line">&lt;A,G&gt;</span><br><span class="line">&lt;G,B&gt;</span><br><span class="line">&lt;G,E&gt;</span><br><span class="line">&lt;E,F&gt;</span><br><span class="line">&lt;F,D&gt;</span><br><span class="line">&lt;A,C&gt;</span><br><span class="line"></span><br><span class="line">A G B E F D C <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p><code>特点：</code>从起始点开始，采用贪心算法的策略，每次遍历到<br><code>算法思想：</code>设置两个顶点的集合S和T，S中存放已找到最短路径的顶点，T中存放当前还未找到最短路径的顶点。开始时S中只包含原点，然后从T中选择到原点路径最短的顶点加到S中，S中每加入新的顶点u，都要修改原点到T中点的最短距离，最短距离为当前最短路径和原点经过u到该顶点的距离的较小者；重复此过程，直到T中顶点都加入S中。<br>示例代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Dijkstra</span><span class="params">(Graph graph,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[graph.getNumOfVertex()];<span class="comment">//最短距离</span></span><br><span class="line">        <span class="type">int</span>[] visited=<span class="keyword">new</span> <span class="title class_">int</span>[graph.getNumOfVertex()];<span class="comment">//是否被访问</span></span><br><span class="line">        <span class="type">int</span>[] path=<span class="keyword">new</span> <span class="title class_">int</span>[graph.getNumOfVertex()];<span class="comment">//当前最短路径的前一个结点</span></span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minDis=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录v到直接到其他顶点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.getNumOfVertex(); i++) &#123;</span><br><span class="line">            dist[i]=graph.getWeightOfEdges(v,i);</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=v&amp;&amp;dist[i]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                path[i]=v;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                path[i]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; graph.getNumOfVertex(); i++) &#123;</span><br><span class="line">            minDis=Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//获得未访问顶点的最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.getNumOfVertex(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;minDis)&#123;</span><br><span class="line">                    u=j;</span><br><span class="line">                    minDis=dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minDis==Integer.MAX_VALUE) <span class="keyword">return</span>;</span><br><span class="line">            visited[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新dist和path</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.getNumOfVertex(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph.getWeightOfEdges(u,j)&lt;Integer.MAX_VALUE&amp;&amp;dist[u]+ graph.getWeightOfEdges(u,j)&lt;dist[j])&#123;</span><br><span class="line">                        dist[j]=dist[u]+ graph.getWeightOfEdges(u,j);</span><br><span class="line">                        path[j]=u;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d:dist) &#123;</span><br><span class="line">            System.out.print(d+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Graph g=Graph.example();</span><br><span class="line">        Dijkstra(g,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述Graph类的example方法加上以下代码  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.getNumOfVertex(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph.edge[i][j]==<span class="number">0</span>&amp;&amp;i!=j)</span><br><span class="line">                    graph.edge[i][j]=<span class="number">9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p><code>基本思想：</code></p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>算法思路：  </p>
<ol>
<li>找出最优解的性质，并刻画其结构特征（寻找最优解的子问题结构）</li>
<li>递归地定义最优值（根据子问题结构建立问题的递归式，求解最优值）</li>
<li>以自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解<br>例1：矩阵连乘</li>
</ol>
<p>例：找出数字三角形中使数字和最大的路径<br>显然，这个问题可以用递归来求解，以下是C语言代码</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引是搜索引擎中最常见的索引方式<br>当我们要做对词的索引时，最容易想到的就是建立一个二维数组存储词汇-文档矩阵，这个实现方法很简单，但是要占据相当大的空间，如果有50w个词汇，100w个文档，那么存储就会超过5000亿字节，远大于一台计算机的内存。<br>我们可以发现这个矩阵具有高度的稀疏性，一个文档中可能只有几百个不同的词，那么我们就只需要根据词汇记录包含这个词汇的文档即可。<br>总而言之：正向索引通常记录文档和包含的词，倒排索引中通常记录词和包含该词的文档。  </p>
<h3 id="单词字典"><a href="#单词字典" class="headerlink" title="单词字典"></a>单词字典</h3><p>对于大规模的文档，可能包含上百万的词汇，快速地找到对应的词直接影响搜索时的响应速度，，所以需要高效的数据结构来对单词字典进行构建和查找，常用的是哈希加链表和树形词典结构。  </p>
<ol>
<li>哈希加链表<br>主体是哈希表，每一项保存一个指向冲突链表的指针。</li>
<li>树形结构<br>B树（B+树）是高效的查找结构，但是不同意哈希查找，B树需要字典项能够按照大小排序<br>一个倒排索引是由单词词典和倒排列表组成的，</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/18/%E5%9F%B9%E8%AE%AD%E8%AE%B0%E5%BD%95/" rel="prev" title="培训记录">
      <i class="fa fa-chevron-left"></i> 培训记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" rel="next" title="代码规范">
      代码规范 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">线性结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">查找算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">四种遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%98%E5%BD%A2"><span class="nav-number">4.2.2.</span> <span class="nav-text">二叉树的变形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.3.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">4.3.1.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.3.2.</span> <span class="nav-text">红黑树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.1.</span> <span class="nav-text">求最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E8%BE%B9%E6%B3%95%EF%BC%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">Kruskal算法（加边法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.2.</span> <span class="nav-text">Prim算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">5.2.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.2.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">5.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">5.4.</span> <span class="nav-text">关键路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">倒排索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E5%AD%97%E5%85%B8"><span class="nav-number">7.1.</span> <span class="nav-text">单词字典</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mingyu Kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mingyu Kang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
